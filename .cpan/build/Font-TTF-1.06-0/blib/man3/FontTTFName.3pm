.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Font::TTF::Name 3pm"
.TH Font::TTF::Name 3pm "2016-08-03" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::Name \- String table for a TTF font
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Strings are held by number, platform, encoding and language. Strings are
accessed as:
.PP
.Vb 1
\&    $f\->{\*(Aqname\*(Aq}{\*(Aqstrings\*(Aq}[$number][$platform_id][$encoding_id]{$language_id}
.Ve
.PP
Notice that the language is held in an associative array due to its sparse
nature on some platforms such as Microsoft ($pid = 3). Notice also that the
array order is different from the stored array order (platform, encoding,
language, number) to allow for easy manipulation of strings by number (which is
what I guess most people will want to do).
.PP
By default, \f(CW$Font::TTF::Name::utf8\fR is set to 1, and strings will be stored as \s-1UTF8\s0 wherever
possible. The method \f(CW\*(C`is_utf8\*(C'\fR can be used to find out if a string in a particular
platform and encoding will be returned as \s-1UTF8.\s0 Unicode strings are always
converted if utf8 is requested. Otherwise, strings are stored according to platform:
.PP
You now have to set <$Font::TTF::Name::utf8> to 0 to get the old behaviour.
.IP "Apple Unicode (platform id = 0)" 4
.IX Item "Apple Unicode (platform id = 0)"
Data is stored as network ordered \s-1UCS2.\s0 There is no encoding id for this platform
but there are language ids as per Mac language ids.
.IP "Mac (platform id = 1)" 4
.IX Item "Mac (platform id = 1)"
Data is stored as 8\-bit binary data, leaving the interpretation to the user
according to encoding id.
.IP "Unicode (platform id = 2)" 4
.IX Item "Unicode (platform id = 2)"
Currently stored as 16\-bit network ordered \s-1UCS2.\s0 Upon release of Perl 5.005 this
will change to utf8 assuming current \s-1UCS2\s0 semantics for all encoding ids.
.IP "Windows (platform id = 3)" 4
.IX Item "Windows (platform id = 3)"
As per Unicode, the data is currently stored as 16\-bit network ordered \s-1UCS2.\s0 Upon
release of Perl 5.005 this will change to utf8 assuming current \s-1UCS2\s0 semantics for
all encoding ids.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
.IP "strings" 4
.IX Item "strings"
An array of arrays, etc.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$t\->read"
.el .SS "\f(CW$t\fP\->read"
.IX Subsection "$t->read"
Reads all the names into memory
.ie n .SS "$t\->out($fh)"
.el .SS "\f(CW$t\fP\->out($fh)"
.IX Subsection "$t->out($fh)"
Writes out all the strings
.ie n .SS "$t\->XML_element($context, $depth, $key, $value)"
.el .SS "\f(CW$t\fP\->XML_element($context, \f(CW$depth\fP, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$t->XML_element($context, $depth, $key, $value)"
Outputs the string element in nice \s-1XML\s0 (which is all the table really!)
.ie n .SS "$t\->XML_end($context, $tag, %attrs)"
.el .SS "\f(CW$t\fP\->XML_end($context, \f(CW$tag\fP, \f(CW%attrs\fP)"
.IX Subsection "$t->XML_end($context, $tag, %attrs)"
Store strings in the right place
.ie n .SS "$t\->\fBminsize()\fP"
.el .SS "\f(CW$t\fP\->\fBminsize()\fP"
.IX Subsection "$t->minsize()"
Returns the minimum size this table can be. If it is smaller than this, then the table
must be bad and should be deleted or whatever.
.ie n .SS "is_utf8($pid, $eid)"
.el .SS "is_utf8($pid, \f(CW$eid\fP)"
.IX Subsection "is_utf8($pid, $eid)"
Returns whether a string of a given platform and encoding is going to be in \s-1UTF8\s0
.SS "find_name($nid)"
.IX Subsection "find_name($nid)"
Hunts down a name in all the standard places and returns the string and for an
array context the pid, eid & lid as well
.SS "remove_name($nid)"
.IX Subsection "remove_name($nid)"
Removes all strings with the given name id from the table.
.ie n .SS "set_name($nid, $str[, $lang[, @cover]])"
.el .SS "set_name($nid, \f(CW$str\fP[, \f(CW$lang\fP[, \f(CW@cover\fP]])"
.IX Subsection "set_name($nid, $str[, $lang[, @cover]])"
Sets the given name id string to \f(CW$str\fR for all platforms and encodings that
this module can handle. If \f(CW$lang\fR is set, it is interpretted as a language
tag and if the particular language of a string is found to match, then
that string is changed, otherwise no change occurs.
.PP
If supplied, \f(CW@cover\fR should be a list of references to two-element arrays 
containing pid,eid pairs that should be added to the name table if not already present.
.PP
This function does not add any names to the table unless \f(CW@cover\fR is supplied.
.ie n .SS "Font::TTF::Name\->match_lang($pid, $lid, $lang)"
.el .SS "Font::TTF::Name\->match_lang($pid, \f(CW$lid\fP, \f(CW$lang\fP)"
.IX Subsection "Font::TTF::Name->match_lang($pid, $lid, $lang)"
Compares the language associated to the string of given platform and language
with the given language tag. If the language matches the tag (i.e. is equal
or more defined than the given language tag) returns true. This is calculated
by finding whether the associated language tag starts with the given language
tag.
.ie n .SS "Font::TTF::Name\->get_lang($pid, $lid)"
.el .SS "Font::TTF::Name\->get_lang($pid, \f(CW$lid\fP)"
.IX Subsection "Font::TTF::Name->get_lang($pid, $lid)"
Returns the language tag associated with a particular platform and language id
.ie n .SS "Font::TTF::Name\->find_lang($pid, $lang)"
.el .SS "Font::TTF::Name\->find_lang($pid, \f(CW$lang\fP)"
.IX Subsection "Font::TTF::Name->find_lang($pid, $lang)"
Looks up the language name and returns a lang id if one exists
.SS "Font::TTF::Name\->\fBpe_list()\fP"
.IX Subsection "Font::TTF::Name->pe_list()"
Returns an array of references to two-element arrays 
containing pid,eid pairs that already exist in this name table.
Useful for creating \f(CW@cover\fR parameter to \fBset_name()\fR.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Unicode type strings will be stored in utf8 for all known platforms,
once Perl 5.6 has been released and I can find all the mapping tables, etc.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken <http://scripts.sil.org/FontUtils>.
.SH "LICENSING"
.IX Header "LICENSING"
Copyright (c) 1998\-2016, \s-1SIL\s0 International (http://www.sil.org)
.PP
This module is released under the terms of the Artistic License 2.0. 
For details, see the full text of the license in the file \s-1LICENSE.\s0
